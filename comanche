#!/usr/bin/perl

###############################################
##      Create by boulangc and deconind      ##
###############################################


# Handler sur la mort des fils
$SIG{'CHLD'} = sub {
	$i --;
	wait();
};


# Handler de terminaison du programme
$SIG{'USR1'} = sub {
	writelog("stop");
	close( SOCKET );
	exit 0;
};


use Socket;
use File::MimeInfo;


# Test sur le parametre
if( $ARGV[0] eq "start" ) {
	
	# Si lancement du serveur
	$pid = fork();
	if( defined $pid && $pid != 0 ) {
		open( PID, ">pid" );
		print PID $pid;
		close( PID );
		exit 0;
	}
} elsif ( $ARGV[0] eq "stop" ) {
	
	# Si arrêt du serveur
	open( PID, "pid" );
	kill( 'USR1', <PID> );
	close( PID );
	exit 0;
} else {
	
	# Si pas d'argument
	exit 1;
}

# Lecture du fichier de configuration
defConfig();

# Creation du logfile si aucun
open( LOG, ">>$logfile" );
close( LOG );


###############################################
##               Code principal              ##
###############################################


# Initialisation du serveur
socket( SOCKET, PF_INET, SOCK_STREAM, getprotobyname( 'tcp' ) );
setsockopt( SOCKET, SOL_SOCKET, SO_REUSEADDR, 1 ) || die( 'setsockopt' );

$addr = sockaddr_in ($port, INADDR_ANY);


# Lancement du serveur
bind( SOCKET, $addr ) || die( 'bind' );
listen( SOCKET, SOMAXCONN ) || die( 'listen' );


# Ecriture du demarrage dans le log
writelog("start");


# Boucle principale du serveur
while( 1 ) {
    accept( CLIENT, SOCKET );
	
	# Test du nombre de fils
	if ( $i >= $clients ) {
		wait();
	}
	
	# Creation d'un fils pour le client
    $pid = fork();
    
    if( $pid == 0 ) {
		
		# Traitement du client par le fils
        select CLIENT;
        $|= 1;
		
		$req = <CLIENT>;
		$req =~ /^GET (.*) HTTP\/1\.1/ || err400;
        $req = $1;
        $req =~ /(.*)\?(.*)/;
        $req = $2;
        @param = split("&", $req);
        for $p ( @param ) {
            $p =~ /.*=(.*)/;
            $parameter .= " $1";
        }
        $req = $1;
        
        traiterFichier();
		
		print $full_response;
		
	    close( CLIENT );
		exit 0;
		
	}
	
	close( CLIENT );

}


###############################################
##    Fonction de lecture du fichier conf    ##
###############################################


sub defConfig
{
    open(CONFIG,"comanche.conf");
    
    while (<CONFIG>) {

	    # récupération des routes dans la liste route
	    if( /route/ ) {
	        @lignes = split(" ",$_);
	        @route = ($lignes[1],$lignes[3]);
	    }
	    
	    # récuperation des executions dans la liste exe
	    if( /exec/ ) {
	        @lignes = split(" ",$_);
	        @exe = ($lignes[1],$lignes[3]);
	    }
        
        # récuperation des variables
	    if( /^set\s+(.+)\s+(.+)/ ) {
	        if( $1 eq "port" ) {
	            die( "Port incorrect dans le .conf\n" ) unless ( $2 >= 1 && $2<=65535 );
	        } elsif( $1 eq "default" ) {
	            die( "Nombre de clients incorrect dans le .conf\n" ) unless ( -f $2 );
	        }
	        ${$1}= $2;
	    } 
    }
    
    close(CONFIG);
}


###############################################
##  Fonction d'écriture dans le fichier log  ##
###############################################


sub writelog
{
	my ($mode) = @_;
	if( $mode eq "start" or $mode eq "stop" ) {
		
		# Si lancement ou fermeture du serveur
		$date = time;
		$machine = "local";
		$type = $mode;
		$requete = $port;
		$projection = "";
		$reponse = "";
	} else {
	    $date = time;
	    $machine = shift;
	    $type = shift;
	    $requete = shift;
	    $projection = shift;
	    $reponse = shift;
	}
	
	# Ecriture dans le log
	my $line = "$date;$type;$machine;$requete;$projection;$reponse\n";
	open( LOG, ">>$logfile" );
	print LOG $line;
	close( LOG );
}


###############################################
##    Fonction de traitement de la requete   ##
###############################################


sub traiterFichier {
    # Recherche dans le repertoire de base
    $req =~ /.*\.(.*)/;
    
    if( -f "$basedir\/$req" && ( $1 eq "html" || $1 eq "txt" || $1 eq "jpg" || $1 eq "css" ) ) {
    
        # Si un fichier correspond
        $type = mimetype($req);
        respFile("$basedir\/$req", $type);
    } elsif( -d "$basedir\/$req" ) {
        if( -f "$basedir\/$req\/index.html" ) {
            
            # Si il y a un fichier index.html dans le dossier
            respFile( "$basedir\/$req\/index.html" );
        } else { 
            
            # Sinon
            respListFile($req);
        }
    } elsif( -x "$basedir\/$req" ) {
        respExec($req);
    } else {
        err404();
    }
}


###############################################
##           Fonctions de réponses           ##
###############################################


# Retourne un page d'erreur 400
sub err400
{
    $reponse =  "<html><body>".
                "<h3>400 Bad Request</h3>".
                "Votre requête n'est pas valide".
                "</body></html>";
    resp("404 Bad Request", "text/html");
}

# Retourne la page de base en erreur 404
sub err404
{
    respFile($default, "404 Not Found", "text/html");
}

# Crée une page répertoriant le contenu d'un dossier
# param :
#   - path
sub respListFile
{
    $dir = shift;
    
    $reponse =  "<html><head><link rel='stylesheet' /></head><body>".
                "<h2>$dir</h2>".
                "<ul>";
    
    opendir( REP, "$basedir\/$dir" );
    for $f ( sort readdir( REP ) ) {
        $path = "$dir\/$f";
        $path =~ s/\/\//\//g;
        if( -d "$basedir\/$path" ) {
            $class = " class='dossier' ";
        } else {
            $class = "";
        }
        $reponse .= "<li $class><a $class href='$path'>$f</a></li>";
    }
    
    $reponse .= "</ul>".
                "</body></html>";
    resp( "200 OK", "text/html" );
}

# Exécute un script
# param :
#   - file to exec
sub respExec {
    $file = shift;
    $reponse = "<html><body>".qx/$basedir\/$file$parameter/."</body></html>";
    resp( "200 OK", "text/html" );
}

# Lit un fichier
# param :
#   - file full path
#   - http status
sub respFile
{
    open(FILE, shift);
    
    while( <FILE> ) {
        $reponse = $reponse.$_;
    }
    
    close(FILE);
    
    resp(shift, shift);
}

# param :
#   - http status
sub resp
{
    $full_response = "HTTP/1.1 ".shift."\r\n" .
        "Content-Type: ".shift."\r\n" .
        "Content-Length: ".length($reponse)."\r\n\r\n" .
        $reponse;
}
