#!/usr/bin/perl

###############################################
##      Create by boulangc and deconind      ##
###############################################


# Handler sur la mort des fils
$SIG{CHLD} = sub {
	$i --;
	undef $pid[wait()];
};


# Handler de terminaison du programme
$SIG{'USR1'} = sub {
	writelog("stop");
    unlink 'pid';
	close( SOCKET );
	exit 0;
};

# Handler de statut du programme
$SIG{'USR2'} = sub {
    print STDOUT "Nombre de requêtes reçues : $reqrecues.\n";
};


use Socket;
use File::MimeInfo;

$reqrecues      = 0;
$reqtraitees    = 0;


# Test sur le parametre
if( $ARGV[0] eq "start" ) {
	
	# Si lancement du serveur
	$pid = fork();
	if( defined $pid && $pid != 0 ) {
		open( PID, ">pid" );
		print PID $pid;
		close( PID );

		exit 0;
	}
} elsif ( $ARGV[0] eq "stop" ) {
	
	# Si arrêt du serveur
	open( PID, "pid" );
	kill( 'USR1', <PID> );
	close( PID );

	exit 0;
}
elsif ( $ARGV[0] eq "status" ) {
    
    # Si demande de statut
    open( PID, "pid" );
	kill( 'USR2', <PID> );
    close( PID );
    
	exit O;
}
 else {
	
	# Si pas d'argument
	exit 1;
}

# Lecture du fichier de configuration
defConfig();

# Creation du logfile si aucun
open( LOG, ">>".$conf{"general"}{"logfile"} );
close( LOG );


###############################################
##               Code principal              ##
###############################################


# Initialisation du serveur
socket( SOCKET, PF_INET, SOCK_STREAM, getprotobyname( 'tcp' ) );
setsockopt( SOCKET, SOL_SOCKET, SO_REUSEADDR, 1 ) || die( 'setsockopt' );

$addr = sockaddr_in ($conf{'general'}{'port'}, INADDR_ANY);


# Lancement du serveur
bind( SOCKET, $addr ) || die( 'bind' );
listen( SOCKET, SOMAXCONN ) || die( 'listen' );


# Ecriture du demarrage dans le log
writelog("start");


# Boucle principale du serveur
while( 1 ) {
    accept( CLIENT, SOCKET ) or next;
	$reqrecues ++;

	# Test du nombre de fils
	if ( $i >= $conf{'general'}{'clients'} ) {
		$reponse =  "<html><body>".
		            "<h3>503 Service Unavailable</h3>".
		            "Trop de connexions en simultannees".
		            "</body></html>";
        resp( "text/html", "503 Service Unavailable" );
        writelog("get-s", "", "", "error", "503 Service Unavailable");
		
	    print $full_response;
	
        close( CLIENT );
	} else {

	    # Creation d'un fils pour le client
        $pid = fork();
        
        if( $pid != 0 ) {

            # Incrémente le nombre de fils
            $i ++;
            close( CLIENT );
        } else {
		
		    # Traitement du client par le fils
		    
		    $client = getpeername(CLIENT);
		    open( STDERR, ">/dev/null" );
            ( $port, $iaddr ) = sockaddr_in( $client );
            $ip = inet_ntoa( $iaddr );
		
            select CLIENT;
            $|= 1;
		
		    $request = <CLIENT>;
                    
		    chop $request;
		    chop $request;
		    $request =~ /^GET (.*) HTTP\/1\.1/ || err400;
            $req = $1;
            $req =~ /(.*)\?(.*)/;
            $req = $2;
            @param = split("&", $req);
            for $p ( @param ) {
                $p =~ /.*=(.*)/;
                $parameter .= " $1";
            }
            $req = $1;
            $c = chop $req;
            $req .= $c if( $c ne "/" );
            
            print STDOUT $route[$req];

            traiterFichier();

		
		    print $full_response;
		
	        close( CLIENT );
		    exit 0;
		
	    }
    }
}


###############################################
##    Fonction de lecture du fichier conf    ##
###############################################


sub defConfig
{
    open(CONFIG,"comanche.conf");
    undef $conf;

    while (<CONFIG>) {

	    # récupération des routes dans la liste route
	    if( /route/ ) {
	        @lignes = split(" ",$_);
	        $conf{'route'}{$lignes[1]} = $lignes[3];
	    }
	    
	    # récuperation des executions dans la liste exe
	    if( /exec/ ) {
	        @lignes = split(" ",$_);
	        $conf{'exe'}{$lignes[1]} = $lignes[3];
	    }
        
        # récuperation des variables
	    if( /^set\s+(.+)\s+(.+)/ ) {
	        if( $1 eq "port" ) {
	            die( "Port incorrect dans le .conf\n" ) unless ( $2 >= 1 && $2<=65535 );
	        } elsif( $1 eq "default" ) {
	            die( "Le fichier par défaut dans le .conf n'existe pas.\n" ) unless ( -f $2 );
	        }
	        $conf{'general'}{$1} = $2;
	    } 
    }
    
    close(CONFIG);
}


###############################################
##  Fonction d'écriture dans le fichier log  ##
###############################################


sub writelog
{
	my ($mode) = @_;
	if( $mode eq "start" or $mode eq "stop" ) {
		
		# Si lancement ou fermeture du serveur
		$date = time;
		$machine = "local";
		$type = $mode;
		$requete = $port;
		$projection = "";
		$reponse = "";
	} else {
	    $date = time;
	    $machine = shift;
	    $type = shift;
	    $requete = shift;
	    $projection = shift;
	    $reponse = shift;
	}
	
	# Ecriture dans le log
	my $line = "$date;$type;$machine;$requete;$projection;$reponse\n";
	open( LOG, ">>$conf{'general'}{'logfile'}" );
	print LOG $line;
	close( LOG );
}


###############################################
##    Fonction de traitement de la requete   ##
###############################################


sub traiterFichier {
    # Recherche dans le repertoire de base
    $req =~ /.*\.(.*)/;
    
    if( -f "$conf{'general'}{'basedir'}$req" && ( $1 eq "html" || $1 eq "txt" || $1 eq "jpg" || $1 eq "css" ) ) {
    
        # Si un fichier correspond
        $type = mimetype($req);
        respFile("$conf{'general'}{'basedir'}$req", $type, "200 OK");
    } elsif( -d "$conf{'general'}{'$basedir'}$req" ) {
        if( -f "$conf{'general'}{'basedir'}$req/$conf{'general'}{'index'}" ) {
            
            # Si il y a un fichier index.html dans le dossier
            respFile( "$conf{'general'}{'basedir'}$req/$conf{'index'}{'index'}", "text/html", "200 OK");
        } else {
            
            # Sinon
            respListFile($req);
        }
    } elsif( -x "$conf{'general'}{'basedir'}$req" ) {
        respExec($req);
    } else {
        err404();
    }
}


###############################################
##           Fonctions de réponses           ##
###############################################


# Retourne un page d'erreur 400
sub err400
{
    $reponse =  "<html><body>".
                "<h3>400 Bad Request</h3>".
                "Votre requête n'est pas valide".
                "</body></html>";
    resp("404 Bad Request", "text/html");
    writelog("get-s", "$ip", "$request", "error", "400 Bad Request");
}

# Retourne la page de base en erreur 404
sub err404
{
    respFile($conf{'general'}{'default'}, "text/html", "404 Not Found");
}

# Crée une page répertoriant le contenu d'un dossier
# param :
#   - path
sub respListFile
{
    $dir = shift;
    
    $reponse =  "<html><head><link rel='stylesheet' /></head><body>".
                "<h2>$dir</h2>".
                "<ul>";
    
    opendir( REP, "$conf{'general'}{'basedir'}$dir" );
    for $f ( sort readdir( REP ) ) {
        $path = "$dir\/$f";
        if( -d "$conf{'general'}{'basedir'}$path" ) {
            $class = " class='dossier' ";
        } else {
            $class = "";
        }
        $reponse .= "<li $class><a $class href='$path'>$f</a></li>";
    }
    
    $reponse .= "</ul>".
                "</body></html>";
    resp( "200 OK", "text/html" );
    writelog("get-s", "$ip", "$request", "$conf{'general'}{'basedir'}$req", "200 OK");
}

# Exécute un script
# param :
#   - file to exec
sub respExec {
    $file = shift;
    $reponse = "<html><body>".qx/$basedir$file$parameter/."</body></html>";
    resp( "200 OK", "text/html" );
    writelog("get-d", "$ip", "$request", "$conf{'general'}{'basedir'}$file", "200 OK");
}

# Lit un fichier
# param :
#   - file full path
#   - http status
sub respFile
{
    $file = shift;
    open(FILE, $file);
    
    while( <FILE> ) {
        $reponse = $reponse.$_;
    }
    
    close(FILE);
    
    $type = shift;
    $code = shift;
    resp($type, $code);
    writelog("get-s", "$ip", "$request", "$file", "$code");
}

# param :
#   - http status
sub resp
{
    $full_response = "HTTP/1.1 ".shift."\r\n" .
        "Content-Type: ".shift."\r\n" .
        "Content-Length: ".length($reponse)."\r\n\r\n" .
        $reponse;
}
